Index: Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/controller/LineTaskController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.job.dispatchService.lineManager.controller;\r\n\r\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\r\nimport com.job.common.pojo.FlowProcessRelation;\r\nimport com.job.common.pojo.Line;\r\nimport com.job.common.pojo.Order;\r\nimport com.job.common.pojo.Work;\r\nimport com.job.dispatchService.lineManager.service.FlowProcessRelationService;\r\nimport com.job.dispatchService.lineManager.service.LineService;\r\nimport com.job.dispatchService.lineManager.service.FlowService;\r\nimport com.job.dispatchService.work.controller.WorkController;\r\nimport com.job.dispatchService.work.service.WorkService;\r\nimport io.netty.util.internal.StringUtil;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.scheduling.annotation.Async;\r\nimport org.springframework.scheduling.annotation.Scheduled;\r\nimport org.springframework.stereotype.Component;\r\nimport com.job.common.result.Result;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author 庸俗可耐\r\n * @create 2023-07-10-20:30\r\n * @description\r\n */\r\n@Component\r\npublic class LineTaskController {\r\n\r\n    @Autowired\r\n    private WorkController workController;\r\n    @Autowired\r\n    private LineService lineService;\r\n\r\n    @Autowired\r\n    private FlowService flowService;\r\n\r\n    @Autowired\r\n    private FlowProcessRelationService flowProcessRelationService;\r\n    @Autowired\r\n    private WorkService workService;\r\n\r\n\r\n    @Async\r\n    public void lineInstance(Line line) throws InterruptedException{\r\n        // TODO: 2023/7/10 流水线实列执行流程\r\n        FlowProcessRelation firstRelation;\r\n        String firstProcessId;\r\n        String flowId;\r\n        String lineName = line.getLine();\r\n        String lineId = line.getId();\r\n        Thread.currentThread().setName(lineName+lineId);\r\n        //订单队列\r\n        List<Order> orderQueue = new LinkedList<>();\r\n        if(orderQueue.isEmpty()==false&&line.getLineStatus().equals(\"0\")){\r\n            Order order = orderQueue.get(0);\r\n            orderQueue.remove(order);\r\n            //查询该订单是否有工单关联\r\n            LambdaQueryWrapper<Work> queryWrapper = new LambdaQueryWrapper<>();\r\n            queryWrapper\r\n                    .eq(Work::getWOrderId,order.getOrderId());\r\n            Work work = workService.getOne(queryWrapper);\r\n            \r\n            flowId = line.getLineFlowId();\r\n            if(work!=null){\r\n                //该订单曾经被执行过\r\n                // TODO: 2023/7/13 如何接取该订单异常的那个工序 \r\n                firstProcessId = work.getWProcessId();\r\n            }else{\r\n                //该订单未被执行\r\n                LambdaQueryWrapper<FlowProcessRelation> queryWrapper1 = new LambdaQueryWrapper<>();\r\n                queryWrapper1\r\n                        .eq(FlowProcessRelation::getIsDelete,1)\r\n                        .eq(FlowProcessRelation::getFlowId,flowId)\r\n                        .eq(FlowProcessRelation::getSortNum,\"0\");\r\n                FlowProcessRelation flowProcessRelation = flowProcessRelationService.getOne(queryWrapper1);\r\n                firstProcessId = flowProcessRelation.getProcessId();\r\n            }\r\n            //获取头工序\r\n            LambdaQueryWrapper<FlowProcessRelation> queryWrapper2 = new LambdaQueryWrapper<>();\r\n            queryWrapper2\r\n                    .eq(FlowProcessRelation::getIsDelete,1)\r\n                    .eq(FlowProcessRelation::getProcessId,firstProcessId)\r\n                    .eq(FlowProcessRelation::getFlowId,flowId);\r\n            firstRelation = flowProcessRelationService.getOne(queryWrapper2);\r\n            if(firstRelation!=null){\r\n                //将流水线状态修改为繁忙\r\n                order.setProductionStatus(2);\r\n                line.setLineStatus(\"2\");\r\n            }\r\n            FlowProcessRelation relation = firstRelation;\r\n            //遍历工序开始生产\r\n            while(!StringUtil.isNullOrEmpty(relation.getNextProcessId())){\r\n                //调用工单处理方法\r\n                String currentProcessId = relation.getProcessId();\r\n                String workingStatus = String.valueOf(workController.working(currentProcessId,order.getOrderId()));\r\n                if(\"error\".equals(workingStatus)){\r\n                    //如果工单运行失败\r\n                    order.setProductionStatus(3);\r\n                    line.setLineStatus(\"3\");\r\n                }else if(\"ok\".equals(workingStatus)){\r\n                    //如果工单运行成功，获取下一个工序\r\n                    LambdaQueryWrapper<FlowProcessRelation> queryWrapper3 = new LambdaQueryWrapper<>();\r\n                    queryWrapper3\r\n                            .eq(FlowProcessRelation::getIsDelete,1)\r\n                            .eq(FlowProcessRelation::getProcessId,relation.getNextProcessId())\r\n                            .eq(FlowProcessRelation::getFlowId,flowId);\r\n                    relation = flowProcessRelationService.getOne(queryWrapper3);\r\n                }\r\n            }\r\n            //判断此时的流程是否为最后的流程\r\n           if(\"lastProcess\".equals(relation.getProcessType())){\r\n               //调用工单处理方法\r\n               String currentProcessId = relation.getProcessId();\r\n               String workingStatus = String.valueOf(workController.working(currentProcessId,order.getOrderId()));\r\n               if(\"error\".equals(workingStatus)){\r\n                   //如果工单运行失败\r\n\r\n               }else if(\"ok\".equals(workingStatus)){\r\n                   //如果工单运行成功\r\n                   order.setProductionStatus(4);\r\n                   line.setLineStatus(\"0\");\r\n               }\r\n           }\r\n        }\r\n    }\r\n\r\n    @Async\r\n    @Scheduled(initialDelay = 0,fixedRate = 3000)\r\n    public void queryOrders() throws InterruptedException {\r\n        // TODO: 2023/7/10 每隔3秒执行一次查询订单\r\n\r\n    }\r\n    \r\n    @Scheduled(initialDelay = 0,fixedDelay = 5000)\r\n    @Async\r\n    public void lineTask() throws InterruptedException {\r\n        LambdaQueryWrapper<Line> queryWrapper = new LambdaQueryWrapper<>();\r\n        queryWrapper\r\n                .eq(Line::getIsDelete,1)\r\n                .eq(Line::getLineStatus,\"0\");\r\n        List<Line> list = lineService.list(queryWrapper);\r\n        if(list.isEmpty()==false&&list.size()>0){\r\n            for(Line line : list){\r\n                String lineName = line.getLine();\r\n                String lineId = line.getId();\r\n                Thread threadByName = findThreadByName(lineName+lineId);\r\n                if(threadByName==null){\r\n                    lineInstance(line);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 根据线程名获取线程\r\n     * @param name\r\n     * @return\r\n     */\r\n    private static Thread findThreadByName(String name) {\r\n        for (Thread thread : Thread.getAllStackTraces().keySet()) {\r\n            if (thread.getName().equals(name)) {\r\n                return thread;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/controller/LineTaskController.java b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/controller/LineTaskController.java
--- a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/controller/LineTaskController.java	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
+++ b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/controller/LineTaskController.java	(date 1689429466775)
@@ -15,7 +15,7 @@
 import org.springframework.scheduling.annotation.Async;
 import org.springframework.scheduling.annotation.Scheduled;
 import org.springframework.stereotype.Component;
-import com.job.common.result.Result;
+
 import java.util.LinkedList;
 import java.util.List;
 
@@ -35,6 +35,9 @@
     @Autowired
     private FlowService flowService;
 
+    @Autowired
+    private RedisCache redisCache;
+
     @Autowired
     private FlowProcessRelationService flowProcessRelationService;
     @Autowired
Index: Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/config/RedisConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.job.dispatchService.lineManager.config;\r\n\r\n\r\nimport com.job.dispatchService.lineManager.utils.FastJsonRedisSerializer;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\n\r\n@Configuration\r\npublic class RedisConfig {\r\n \r\n    @Bean\r\n    @SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\r\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\r\n    {\r\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\r\n        template.setConnectionFactory(connectionFactory);\r\n \r\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\r\n \r\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\r\n        template.setKeySerializer(new StringRedisSerializer());\r\n        template.setValueSerializer(serializer);\r\n \r\n        // Hash的key也采用StringRedisSerializer的序列化方式\r\n        template.setHashKeySerializer(new StringRedisSerializer());\r\n        template.setHashValueSerializer(serializer);\r\n \r\n        template.afterPropertiesSet();\r\n        return template;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/config/RedisConfig.java b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/config/RedisConfig.java
--- a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/config/RedisConfig.java	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
+++ b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/config/RedisConfig.java	(date 1689429466764)
@@ -1,6 +1,5 @@
 package com.job.dispatchService.lineManager.config;
 
-
 import com.job.dispatchService.lineManager.utils.FastJsonRedisSerializer;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
@@ -8,26 +7,32 @@
 import org.springframework.data.redis.core.RedisTemplate;
 import org.springframework.data.redis.serializer.StringRedisSerializer;
 
+//用于配置 RedisTemplate 的 RedisConfig 类。在这个类中，你可以设置 RedisTemplate 的序列化方式、连接工厂等配置。
 @Configuration
 public class RedisConfig {
- 
+
     @Bean
     @SuppressWarnings(value = { "unchecked", "rawtypes" })
     public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)
     {
+//        创建redistemplate对象
         RedisTemplate<Object, Object> template = new RedisTemplate<>();
+//        将连接工厂设置到redistemplate中以便与redis通信
         template.setConnectionFactory(connectionFactory);
- 
+//        创建一个 FastJsonRedisSerializer 对象，并将其中传入的 Class 设置为 Object.class，表示要序列化和反序列化的对象类型是 Object。
         FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);
- 
-        // 使用StringRedisSerializer来序列化和反序列化redis的key值
+
+//        使用StringRedisSerializer来序列化和反序列化redis的key值
+//        设置键的序列化器为 StringRedisSerializer
         template.setKeySerializer(new StringRedisSerializer());
+//        使用 setHashValueSerializer 方法设置哈希值的序列化器为上面创建的 FastJsonRedisSerializer。
         template.setValueSerializer(serializer);
- 
+
         // Hash的key也采用StringRedisSerializer的序列化方式
         template.setHashKeySerializer(new StringRedisSerializer());
         template.setHashValueSerializer(serializer);
- 
+
+//      afterPropertiesSet() 方法用于确保 RedisTemplate 的所有属性都已经设置完毕，并作为重要的初始化步骤。该方法会执行一些必要的校验和配置，并保证 RedisTemplate 可以正常运行。
         template.afterPropertiesSet();
         return template;
     }
Index: Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/FastJsonRedisSerializer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.job.dispatchService.lineManager.utils;\r\n\r\nimport com.alibaba.fastjson.JSON;\r\nimport com.alibaba.fastjson.parser.ParserConfig;\r\nimport com.alibaba.fastjson.serializer.SerializerFeature;\r\nimport com.fasterxml.jackson.databind.JavaType;\r\nimport com.fasterxml.jackson.databind.type.TypeFactory;\r\nimport org.springframework.data.redis.serializer.RedisSerializer;\r\nimport org.springframework.data.redis.serializer.SerializationException;\r\nimport java.nio.charset.Charset;\r\n\r\n/**\r\n * Redis使用FastJson序列化\r\n * \r\n * @author sg\r\n */\r\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\r\n{\r\n \r\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\r\n \r\n    private Class<T> clazz;\r\n \r\n    static\r\n    {\r\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\r\n    }\r\n \r\n    public FastJsonRedisSerializer(Class<T> clazz)\r\n    {\r\n        super();\r\n        this.clazz = clazz;\r\n    }\r\n \r\n    @Override\r\n    public byte[] serialize(T t) throws SerializationException\r\n    {\r\n        if (t == null)\r\n        {\r\n            return new byte[0];\r\n        }\r\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\r\n    }\r\n \r\n    @Override\r\n    public T deserialize(byte[] bytes) throws SerializationException\r\n    {\r\n        if (bytes == null || bytes.length <= 0)\r\n        {\r\n            return null;\r\n        }\r\n        String str = new String(bytes, DEFAULT_CHARSET);\r\n \r\n        return JSON.parseObject(str, clazz);\r\n    }\r\n \r\n \r\n    protected JavaType getJavaType(Class<?> clazz)\r\n    {\r\n        return TypeFactory.defaultInstance().constructType(clazz);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/FastJsonRedisSerializer.java b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/FastJsonRedisSerializer.java
--- a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/FastJsonRedisSerializer.java	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
+++ b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/FastJsonRedisSerializer.java	(date 1689427828160)
@@ -7,31 +7,36 @@
 import com.fasterxml.jackson.databind.type.TypeFactory;
 import org.springframework.data.redis.serializer.RedisSerializer;
 import org.springframework.data.redis.serializer.SerializationException;
+
 import java.nio.charset.Charset;
 
 /**
  * Redis使用FastJson序列化
- * 
+ *  FastJson 序列化和反序列化对象的 RedisSerializer 实现类。它实现了 RedisSerializer 接口，用于在 Redis 上存储和获取对象。
  * @author sg
  */
 public class FastJsonRedisSerializer<T> implements RedisSerializer<T>
 {
- 
+
+    //    设置编码格式
     public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
- 
+
     private Class<T> clazz;
- 
+
+    //    使用了 FastJson 的 ParserConfig，将自动类型支持设置为 true，以支持反序列化时的自动类型转换。
     static
     {
         ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
     }
- 
+
     public FastJsonRedisSerializer(Class<T> clazz)
     {
         super();
         this.clazz = clazz;
     }
- 
+
+
+    //    方法将对象 t 序列化为字节数组。如果传入的对象为 null，返回一个空字节数组；否则，使用 FastJson 的 toJSONString 方法将对象转换为 JSON 字符串，并将其转换为字节数组。
     @Override
     public byte[] serialize(T t) throws SerializationException
     {
@@ -41,7 +46,8 @@
         }
         return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
     }
- 
+
+    //    方法将字节数组 bytes 反序列化为对象。如果传入的字节数组为 null 或长度为 0，返回 null；否则，将字节数组转换为字符串，并使用 FastJson 的 parseObject 方法将字符串解析为对象。
     @Override
     public T deserialize(byte[] bytes) throws SerializationException
     {
@@ -50,11 +56,11 @@
             return null;
         }
         String str = new String(bytes, DEFAULT_CHARSET);
- 
+
         return JSON.parseObject(str, clazz);
     }
- 
- 
+
+    // 返回一个 JavaType 对象，用于将 Class 对象转换为 FastJson 中的 JavaType。
     protected JavaType getJavaType(Class<?> clazz)
     {
         return TypeFactory.defaultInstance().constructType(clazz);
Index: Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/RedisCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.job.dispatchService.lineManager.utils;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.data.redis.core.BoundSetOperations;\r\nimport org.springframework.data.redis.core.HashOperations;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.core.ValueOperations;\r\nimport org.springframework.stereotype.Component;\r\nimport java.util.*;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\r\n\r\n@Component\r\npublic class RedisCache\r\n{\r\n    @Autowired\r\n    public RedisTemplate redisTemplate;\r\n \r\n    /**\r\n     * 缓存基本的对象，Integer、String、实体类等\r\n     *\r\n     * @param key 缓存的键值\r\n     * @param value 缓存的值\r\n     */\r\n    public <T> void setCacheObject(final String key, final T value)\r\n    {\r\n        redisTemplate.opsForValue().set(key, value);\r\n    }\r\n \r\n    /**\r\n     * 缓存基本的对象，Integer、String、实体类等\r\n     *\r\n     * @param key 缓存的键值\r\n     * @param value 缓存的值\r\n     * @param timeout 时间\r\n     * @param timeUnit 时间颗粒度\r\n     */\r\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\r\n    {\r\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\r\n    }\r\n \r\n    /**\r\n     * 设置有效时间\r\n     *\r\n     * @param key Redis键\r\n     * @param timeout 超时时间\r\n     * @return true=设置成功；false=设置失败\r\n     */\r\n    public boolean expire(final String key, final long timeout)\r\n    {\r\n        return expire(key, timeout, TimeUnit.SECONDS);\r\n    }\r\n \r\n    /**\r\n     * 设置有效时间\r\n     *\r\n     * @param key Redis键\r\n     * @param timeout 超时时间\r\n     * @param unit 时间单位\r\n     * @return true=设置成功；false=设置失败\r\n     */\r\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\r\n    {\r\n        return redisTemplate.expire(key, timeout, unit);\r\n    }\r\n \r\n    /**\r\n     * 获得缓存的基本对象。\r\n     *\r\n     * @param key 缓存键值\r\n     * @return 缓存键值对应的数据\r\n     */\r\n    public <T> T getCacheObject(final String key)\r\n    {\r\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\r\n        return operation.get(key);\r\n    }\r\n \r\n    /**\r\n     * 删除单个对象\r\n     *\r\n     * @param key\r\n     */\r\n    public boolean deleteObject(final String key)\r\n    {\r\n        return redisTemplate.delete(key);\r\n    }\r\n \r\n    /**\r\n     * 删除集合对象\r\n     *\r\n     * @param collection 多个对象\r\n     * @return\r\n     */\r\n    public long deleteObject(final Collection collection)\r\n    {\r\n        return redisTemplate.delete(collection);\r\n    }\r\n \r\n    /**\r\n     * 缓存List数据\r\n     *\r\n     * @param key 缓存的键值\r\n     * @param dataList 待缓存的List数据\r\n     * @return 缓存的对象\r\n     */\r\n    public <T> long setCacheList(final String key, final List<T> dataList)\r\n    {\r\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\r\n        return count == null ? 0 : count;\r\n    }\r\n \r\n    /**\r\n     * 获得缓存的list对象\r\n     *\r\n     * @param key 缓存的键值\r\n     * @return 缓存键值对应的数据\r\n     */\r\n    public <T> List<T> getCacheList(final String key)\r\n    {\r\n        return redisTemplate.opsForList().range(key, 0, -1);\r\n    }\r\n \r\n    /**\r\n     * 缓存Set\r\n     *\r\n     * @param key 缓存键值\r\n     * @param dataSet 缓存的数据\r\n     * @return 缓存数据的对象\r\n     */\r\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\r\n    {\r\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\r\n        Iterator<T> it = dataSet.iterator();\r\n        while (it.hasNext())\r\n        {\r\n            setOperation.add(it.next());\r\n        }\r\n        return setOperation;\r\n    }\r\n \r\n    /**\r\n     * 获得缓存的set\r\n     *\r\n     * @param key\r\n     * @return\r\n     */\r\n    public <T> Set<T> getCacheSet(final String key)\r\n    {\r\n        return redisTemplate.opsForSet().members(key);\r\n    }\r\n \r\n    /**\r\n     * 缓存Map\r\n     *\r\n     * @param key\r\n     * @param dataMap\r\n     */\r\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\r\n    {\r\n        if (dataMap != null) {\r\n            redisTemplate.opsForHash().putAll(key, dataMap);\r\n        }\r\n    }\r\n \r\n    /**\r\n     * 获得缓存的Map\r\n     *\r\n     * @param key\r\n     * @return\r\n     */\r\n    public <T> Map<String, T> getCacheMap(final String key)\r\n    {\r\n        return redisTemplate.opsForHash().entries(key);\r\n    }\r\n \r\n    /**\r\n     * 往Hash中存入数据\r\n     *\r\n     * @param key Redis键\r\n     * @param hKey Hash键\r\n     * @param value 值\r\n     */\r\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\r\n    {\r\n        redisTemplate.opsForHash().put(key, hKey, value);\r\n    }\r\n \r\n    /**\r\n     * 获取Hash中的数据\r\n     *\r\n     * @param key Redis键\r\n     * @param hKey Hash键\r\n     * @return Hash中的对象\r\n     */\r\n    public <T> T getCacheMapValue(final String key, final String hKey)\r\n    {\r\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\r\n        return opsForHash.get(key, hKey);\r\n    }\r\n \r\n    /**\r\n     * 删除Hash中的数据\r\n     * \r\n     * @param key\r\n     * @param hkey\r\n     */\r\n    public void delCacheMapValue(final String key, final String hkey)\r\n    {\r\n        HashOperations hashOperations = redisTemplate.opsForHash();\r\n        hashOperations.delete(key, hkey);\r\n    }\r\n \r\n    /**\r\n     * 获取多个Hash中的数据\r\n     *\r\n     * @param key Redis键\r\n     * @param hKeys Hash键集合\r\n     * @return Hash对象集合\r\n     */\r\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\r\n    {\r\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\r\n    }\r\n \r\n    /**\r\n     * 获得缓存的基本对象列表\r\n     *\r\n     * @param pattern 字符串前缀\r\n     * @return 对象列表\r\n     */\r\n    public Collection<String> keys(final String pattern)\r\n    {\r\n        return redisTemplate.keys(pattern);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/RedisCache.java b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/RedisCache.java
--- a/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/RedisCache.java	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
+++ b/Mesbackend/Dispatch-Service/src/main/java/com/job/dispatchService/lineManager/utils/RedisCache.java	(date 1689427828177)
@@ -6,6 +6,7 @@
 import org.springframework.data.redis.core.RedisTemplate;
 import org.springframework.data.redis.core.ValueOperations;
 import org.springframework.stereotype.Component;
+
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 
@@ -16,10 +17,11 @@
 {
     @Autowired
     public RedisTemplate redisTemplate;
- 
+
+
     /**
      * 缓存基本的对象，Integer、String、实体类等
-     *
+     *s
      * @param key 缓存的键值
      * @param value 缓存的值
      */
@@ -27,7 +29,7 @@
     {
         redisTemplate.opsForValue().set(key, value);
     }
- 
+
     /**
      * 缓存基本的对象，Integer、String、实体类等
      *
@@ -40,32 +42,33 @@
     {
         redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
     }
- 
+
     /**
      * 设置有效时间
      *
      * @param key Redis键
      * @param timeout 超时时间
      * @return true=设置成功；false=设置失败
+     * 时间单位是秒
      */
     public boolean expire(final String key, final long timeout)
     {
         return expire(key, timeout, TimeUnit.SECONDS);
     }
- 
+
     /**
-     * 设置有效时间
+//     * 设置有效时间
      *
      * @param key Redis键
      * @param timeout 超时时间
-     * @param unit 时间单位
+     * @param unit 时间单位可以随便设置
      * @return true=设置成功；false=设置失败
      */
     public boolean expire(final String key, final long timeout, final TimeUnit unit)
-    {
-        return redisTemplate.expire(key, timeout, unit);
-    }
- 
+        {
+            return redisTemplate.expire(key, timeout, unit);
+        }
+
     /**
      * 获得缓存的基本对象。
      *
@@ -77,7 +80,7 @@
         ValueOperations<String, T> operation = redisTemplate.opsForValue();
         return operation.get(key);
     }
- 
+
     /**
      * 删除单个对象
      *
@@ -87,7 +90,7 @@
     {
         return redisTemplate.delete(key);
     }
- 
+
     /**
      * 删除集合对象
      *
@@ -98,7 +101,7 @@
     {
         return redisTemplate.delete(collection);
     }
- 
+
     /**
      * 缓存List数据
      *
@@ -111,7 +114,7 @@
         Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
         return count == null ? 0 : count;
     }
- 
+
     /**
      * 获得缓存的list对象
      *
@@ -122,7 +125,7 @@
     {
         return redisTemplate.opsForList().range(key, 0, -1);
     }
- 
+
     /**
      * 缓存Set
      *
@@ -140,7 +143,7 @@
         }
         return setOperation;
     }
- 
+
     /**
      * 获得缓存的set
      *
@@ -151,10 +154,10 @@
     {
         return redisTemplate.opsForSet().members(key);
     }
- 
+
     /**
      * 缓存Map
-     *
+     *批量添加到hash数据的方法
      * @param key
      * @param dataMap
      */
@@ -164,7 +167,7 @@
             redisTemplate.opsForHash().putAll(key, dataMap);
         }
     }
- 
+
     /**
      * 获得缓存的Map
      *
@@ -175,7 +178,7 @@
     {
         return redisTemplate.opsForHash().entries(key);
     }
- 
+
     /**
      * 往Hash中存入数据
      *
@@ -187,7 +190,13 @@
     {
         redisTemplate.opsForHash().put(key, hKey, value);
     }
- 
+
+//    添加数据分类
+    public <T> void addList(final String hKey, final T value){
+        redisTemplate.opsForHash().put("list",hKey,value);
+    }
+
+
     /**
      * 获取Hash中的数据
      *
@@ -200,10 +209,10 @@
         HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();
         return opsForHash.get(key, hKey);
     }
- 
+
     /**
      * 删除Hash中的数据
-     * 
+     *
      * @param key
      * @param hkey
      */
@@ -212,7 +221,7 @@
         HashOperations hashOperations = redisTemplate.opsForHash();
         hashOperations.delete(key, hkey);
     }
- 
+
     /**
      * 获取多个Hash中的数据
      *
@@ -224,7 +233,7 @@
     {
         return redisTemplate.opsForHash().multiGet(key, hKeys);
     }
- 
+
     /**
      * 获得缓存的基本对象列表
      *
@@ -235,4 +244,15 @@
     {
         return redisTemplate.keys(pattern);
     }
+
+
+    /**
+     * 获得键的过期时间
+     *
+     * @return 对象列表
+     */
+    public Long getCacheExpiration(final String key)
+    {
+        return redisTemplate.getExpire(key,TimeUnit.SECONDS);
+    }
 }
\ No newline at end of file
Index: Mesbackend/CommonUtils/src/main/java/com/job/common/redis/FastJsonRedisSerializer.java
===================================================================
diff --git a/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/FastJsonRedisSerializer.java b/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/FastJsonRedisSerializer.java
deleted file mode 100644
--- a/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/FastJsonRedisSerializer.java	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
+++ /dev/null	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
@@ -1,68 +0,0 @@
-package com.job.common.redis;
-
-import com.alibaba.fastjson.JSON;
-import com.alibaba.fastjson.parser.ParserConfig;
-import com.alibaba.fastjson.serializer.SerializerFeature;
-import com.fasterxml.jackson.databind.JavaType;
-import com.fasterxml.jackson.databind.type.TypeFactory;
-import org.springframework.data.redis.serializer.RedisSerializer;
-import org.springframework.data.redis.serializer.SerializationException;
-
-import java.nio.charset.Charset;
-
-/**
- * Redis使用FastJson序列化
- *  FastJson 序列化和反序列化对象的 RedisSerializer 实现类。它实现了 RedisSerializer 接口，用于在 Redis 上存储和获取对象。
- * @author sg
- */
-public class FastJsonRedisSerializer<T> implements RedisSerializer<T>
-{
-
-//    设置编码格式
-    public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
-
-    private Class<T> clazz;
-
-//    使用了 FastJson 的 ParserConfig，将自动类型支持设置为 true，以支持反序列化时的自动类型转换。
-    static
-    {
-        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
-    }
-
-    public FastJsonRedisSerializer(Class<T> clazz)
-    {
-        super();
-        this.clazz = clazz;
-    }
-
-
-//    方法将对象 t 序列化为字节数组。如果传入的对象为 null，返回一个空字节数组；否则，使用 FastJson 的 toJSONString 方法将对象转换为 JSON 字符串，并将其转换为字节数组。
-    @Override
-    public byte[] serialize(T t) throws SerializationException
-    {
-        if (t == null)
-        {
-            return new byte[0];
-        }
-        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
-    }
-
-//    方法将字节数组 bytes 反序列化为对象。如果传入的字节数组为 null 或长度为 0，返回 null；否则，将字节数组转换为字符串，并使用 FastJson 的 parseObject 方法将字符串解析为对象。
-    @Override
-    public T deserialize(byte[] bytes) throws SerializationException
-    {
-        if (bytes == null || bytes.length <= 0)
-        {
-            return null;
-        }
-        String str = new String(bytes, DEFAULT_CHARSET);
-
-        return JSON.parseObject(str, clazz);
-    }
-
-// 返回一个 JavaType 对象，用于将 Class 对象转换为 FastJson 中的 JavaType。
-    protected JavaType getJavaType(Class<?> clazz)
-    {
-        return TypeFactory.defaultInstance().constructType(clazz);
-    }
-}
\ No newline at end of file
Index: Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisConfig.java
===================================================================
diff --git a/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisConfig.java b/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisConfig.java
deleted file mode 100644
--- a/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisConfig.java	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
+++ /dev/null	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
@@ -1,39 +0,0 @@
-package com.job.common.redis;
-
-import org.springframework.context.annotation.Bean;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.data.redis.connection.RedisConnectionFactory;
-import org.springframework.data.redis.core.RedisTemplate;
-import org.springframework.data.redis.serializer.StringRedisSerializer;
-
-//用于配置 RedisTemplate 的 RedisConfig 类。在这个类中，你可以设置 RedisTemplate 的序列化方式、连接工厂等配置。
-@Configuration
-public class RedisConfig {
-
-    @Bean
-    @SuppressWarnings(value = { "unchecked", "rawtypes" })
-    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)
-    {
-//        创建redistemplate对象
-        RedisTemplate<Object, Object> template = new RedisTemplate<>();
-//        将连接工厂设置到redistemplate中以便与redis通信
-        template.setConnectionFactory(connectionFactory);
-//        创建一个 FastJsonRedisSerializer 对象，并将其中传入的 Class 设置为 Object.class，表示要序列化和反序列化的对象类型是 Object。
-        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);
-
-//        使用StringRedisSerializer来序列化和反序列化redis的key值
-//        设置键的序列化器为 StringRedisSerializer
-        template.setKeySerializer(new StringRedisSerializer());
-//        使用 setHashValueSerializer 方法设置哈希值的序列化器为上面创建的 FastJsonRedisSerializer。
-        template.setValueSerializer(serializer);
-
-        // Hash的key也采用StringRedisSerializer的序列化方式
-        template.setHashKeySerializer(new StringRedisSerializer());
-        template.setHashValueSerializer(serializer);
-
-//      afterPropertiesSet() 方法用于确保 RedisTemplate 的所有属性都已经设置完毕，并作为重要的初始化步骤。该方法会执行一些必要的校验和配置，并保证 RedisTemplate 可以正常运行。
-        template.afterPropertiesSet();
-        return template;
-    }
-}
-
Index: Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisCache.java
===================================================================
diff --git a/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisCache.java b/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisCache.java
deleted file mode 100644
--- a/Mesbackend/CommonUtils/src/main/java/com/job/common/redis/RedisCache.java	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
+++ /dev/null	(revision aee096cc53f21d1e3e1e1ddb9bb9cbb675c53ab6)
@@ -1,258 +0,0 @@
-package com.job.common.redis;
-
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.data.redis.core.BoundSetOperations;
-import org.springframework.data.redis.core.HashOperations;
-import org.springframework.data.redis.core.RedisTemplate;
-import org.springframework.data.redis.core.ValueOperations;
-import org.springframework.stereotype.Component;
-
-import java.util.*;
-import java.util.concurrent.TimeUnit;
-
-@SuppressWarnings(value = { "unchecked", "rawtypes" })
-
-@Component
-public class RedisCache
-{
-    @Autowired
-    public RedisTemplate redisTemplate;
-
-
-    /**
-     * 缓存基本的对象，Integer、String、实体类等
-     *s
-     * @param key 缓存的键值
-     * @param value 缓存的值
-     */
-    public <T> void setCacheObject(final String key, final T value)
-    {
-        redisTemplate.opsForValue().set(key, value);
-    }
-
-    /**
-     * 缓存基本的对象，Integer、String、实体类等
-     *
-     * @param key 缓存的键值
-     * @param value 缓存的值
-     * @param timeout 时间
-     * @param timeUnit 时间颗粒度
-     */
-    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)
-    {
-        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
-    }
-
-    /**
-     * 设置有效时间
-     *
-     * @param key Redis键
-     * @param timeout 超时时间
-     * @return true=设置成功；false=设置失败
-     * 时间单位是秒
-     */
-    public boolean expire(final String key, final long timeout)
-    {
-        return expire(key, timeout, TimeUnit.SECONDS);
-    }
-
-    /**
-//     * 设置有效时间
-     *
-     * @param key Redis键
-     * @param timeout 超时时间
-     * @param unit 时间单位可以随便设置
-     * @return true=设置成功；false=设置失败
-     */
-    public boolean expire(final String key, final long timeout, final TimeUnit unit)
-        {
-            return redisTemplate.expire(key, timeout, unit);
-        }
-
-    /**
-     * 获得缓存的基本对象。
-     *
-     * @param key 缓存键值
-     * @return 缓存键值对应的数据
-     */
-    public <T> T getCacheObject(final String key)
-    {
-        ValueOperations<String, T> operation = redisTemplate.opsForValue();
-        return operation.get(key);
-    }
-
-    /**
-     * 删除单个对象
-     *
-     * @param key
-     */
-    public boolean deleteObject(final String key)
-    {
-        return redisTemplate.delete(key);
-    }
-
-    /**
-     * 删除集合对象
-     *
-     * @param collection 多个对象
-     * @return
-     */
-    public long deleteObject(final Collection collection)
-    {
-        return redisTemplate.delete(collection);
-    }
-
-    /**
-     * 缓存List数据
-     *
-     * @param key 缓存的键值
-     * @param dataList 待缓存的List数据
-     * @return 缓存的对象
-     */
-    public <T> long setCacheList(final String key, final List<T> dataList)
-    {
-        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
-        return count == null ? 0 : count;
-    }
-
-    /**
-     * 获得缓存的list对象
-     *
-     * @param key 缓存的键值
-     * @return 缓存键值对应的数据
-     */
-    public <T> List<T> getCacheList(final String key)
-    {
-        return redisTemplate.opsForList().range(key, 0, -1);
-    }
-
-    /**
-     * 缓存Set
-     *
-     * @param key 缓存键值
-     * @param dataSet 缓存的数据
-     * @return 缓存数据的对象
-     */
-    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)
-    {
-        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);
-        Iterator<T> it = dataSet.iterator();
-        while (it.hasNext())
-        {
-            setOperation.add(it.next());
-        }
-        return setOperation;
-    }
-
-    /**
-     * 获得缓存的set
-     *
-     * @param key
-     * @return
-     */
-    public <T> Set<T> getCacheSet(final String key)
-    {
-        return redisTemplate.opsForSet().members(key);
-    }
-
-    /**
-     * 缓存Map
-     *批量添加到hash数据的方法
-     * @param key
-     * @param dataMap
-     */
-    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)
-    {
-        if (dataMap != null) {
-            redisTemplate.opsForHash().putAll(key, dataMap);
-        }
-    }
-
-    /**
-     * 获得缓存的Map
-     *
-     * @param key
-     * @return
-     */
-    public <T> Map<String, T> getCacheMap(final String key)
-    {
-        return redisTemplate.opsForHash().entries(key);
-    }
-
-    /**
-     * 往Hash中存入数据
-     *
-     * @param key Redis键
-     * @param hKey Hash键
-     * @param value 值
-     */
-    public <T> void setCacheMapValue(final String key, final String hKey, final T value)
-    {
-        redisTemplate.opsForHash().put(key, hKey, value);
-    }
-
-//    添加数据分类
-    public <T> void addList(final String hKey, final T value){
-        redisTemplate.opsForHash().put("list",hKey,value);
-    }
-
-
-    /**
-     * 获取Hash中的数据
-     *
-     * @param key Redis键
-     * @param hKey Hash键
-     * @return Hash中的对象
-     */
-    public <T> T getCacheMapValue(final String key, final String hKey)
-    {
-        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();
-        return opsForHash.get(key, hKey);
-    }
-
-    /**
-     * 删除Hash中的数据
-     *
-     * @param key
-     * @param hkey
-     */
-    public void delCacheMapValue(final String key, final String hkey)
-    {
-        HashOperations hashOperations = redisTemplate.opsForHash();
-        hashOperations.delete(key, hkey);
-    }
-
-    /**
-     * 获取多个Hash中的数据
-     *
-     * @param key Redis键
-     * @param hKeys Hash键集合
-     * @return Hash对象集合
-     */
-    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)
-    {
-        return redisTemplate.opsForHash().multiGet(key, hKeys);
-    }
-
-    /**
-     * 获得缓存的基本对象列表
-     *
-     * @param pattern 字符串前缀
-     * @return 对象列表
-     */
-    public Collection<String> keys(final String pattern)
-    {
-        return redisTemplate.keys(pattern);
-    }
-
-
-    /**
-     * 获得键的过期时间
-     *
-     * @return 对象列表
-     */
-    public Long getCacheExpiration(final String key)
-    {
-        return redisTemplate.getExpire(key,TimeUnit.SECONDS);
-    }
-}
\ No newline at end of file
